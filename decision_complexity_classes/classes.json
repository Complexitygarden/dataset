{
    "class_list":{
        "ALL": {
            "name": "ALL",
            "latex_name": "\\mathsf{ALL}",
            "top": true,
            "description": "The class of all languages.",
            "information": "ALL is the complexity class of all languages. <br>It has shown that various non-uniform classes are equal to ALL, such as $\\mathsf{PP/rpoly}$, $\\mathsf{PostBQP/qpoly}$ [Aar04], $\\mathsf{QIP/qpoly}$ [Raz05] and $\\mathsf{PDQP/qpoly}$ [Aar18]. Additionally, note that $\\mathsf{coALL} = ALL$.",
            "complement":"ALL"
        },
        "NONE": {
            "name": "NONE",
            "latex_name": "\\mathsf{NONE}",
            "bottom": true,
            "description": "The class of no languages.",
            "information": "The 'empty set' of complexity theory, NONE contains no languages but is not equal to the complement of ALL since $\\mathsf{coALL} = ALL$ ."
        },
        "PP": {
            "name": "PP",
            "latex_name": "\\mathsf{PP}",
            "description": "Probabilistic Polynomial Time",
            "information": "The class of decision problems solvable by an NP machine such that <br> <br> <ul> <li> If the answer is yes, then at least half of the computational paths accept </li> <li> If the answer is no, then less than half of the computational paths accept.</li></ul> Defined in [Gil74]. <br> Can be generalized to CH. <br> It has been shown that BPP [KSTT92], BQP [FR98] and $\\mathsf{YQP^*}$ [Yir24] are low for PP (i.e. $\\mathsf{PP}^{\\mathsf{YQP^*}}= PP$)."
        },
        "QMA": {
            "name": "QMA",
            "latex_name": "\\mathsf{QMA}",
            "description": "Quantum Merlin-Arthur",
            "information": "The class of decision problems such that 'yes' instances can be verified efficiently. That is: <br> <br> <ul> <li>If the answer is 'yes', then there exists a quantum state such that the verifier accepts with probability at least 2/3</li> <li>If the answer is 'no', then for all quantum states the verifier rejects with probability at least 2/3.</li></ul> The $k$-local Hamiltonian problem, for $k \\geq 2$, is QMA-complete [KKR04]."
        },
        "QCMA": {
            "name": "QCMA",
            "latex_name": "\\mathsf{QCMA}",
            "description": "Quantum Classical Merlin-Arthur",
            "information": "The class of decision problems for which a 'yes' answer can be efficiently verified by a family of uniform quantum circuits with access to a classical proof. Concretely: <br> <br> <ul> <li>For all 'yes' instances, there exists a poly(|x|) size classical proof such that the verifier accepts with probability at least 2/3</li> <li> For a 'no' instance, for all such classical proofs the verifier rejects with probability at least 2/3.</li></ul> It is equal to $\\mathsf{QCMA}_1$, which is QCMA where the acceptance probability in the yes-case is 1 [JKNN11]. <br> A QCMA-complete problem is GSCONN (Ground State Connectivity), defined in [GS15]. Essentially given a Hamiltonian H and two ground states a,b, the goal is determining whether there exists a sequence of local unitary operations which transforms a to b while every intermediate state is in the ground space of H.<br> It is an open problem whether there exists a classical oracle which separates QCMA from QMA."
        },
        "QIP": {
            "name": "QIP",
            "latex_name": "\\mathsf{QIP}",
            "description": "Quantum Interactive Proof",
            "information": "The class QIP is the quantum computing analogue of the classical complexity class IP, <br> <br> <ul> <li></li></ul><br>For more check out: <a href='https://complexityzoo.net/Complexity_Zoo:Q#qip'>Complexity Zoo</a>"
        },
        "PDQP": {
            "name": "PDQP",
            "latex_name": "\\mathsf{PDQP}",
            "description": "Polynomial Dynamical Quantum Polynomial Time",
            "information": "Generalization of BQP where the machine is allowed to perform measurements without collapsing the wavefunction. Defined in [ABFL16]. <br> PDQP may perform unordered search faster than BQP and contains SZK."
        },
        "P": {
            "name": "P",
            "latex_name": "\\mathsf{P}",
            "description": "Polynomial Time",
            "information": "The class of decision problems solveable in polynomial time by a Turing machine. Defined in [Edm65], [Cob64], [Rab60], and other early seminal papers."
        },
        "BQP": {
            "name": "BQP",
            "latex_name": "\\mathsf{BQP}",
            "description": "Bounded-Error Quantum Polynomial Time",
            "information": "The class of decision problems solvable in polynomial time by a quantum Turing machine. Specifically: <br><br><ul> <li>On 'yes' instances, the verifier accepts with probability at least 2/3. </li> <li> On 'no' instances, the verifier rejects with probability at least 2/3."
        },
        "NP": {
            "name": "NP",
            "latex_name": "\\mathsf{NP}",
            "description": "Non-deterministic Polynomial Time",
            "information": "The class of decision problems for which 'yes' answers are efficiently verifiable. Specifically: <br><br> <ul> <li> There exists a proof for all 'yes' instances such that the verifier accepts wih certainty. </li> <li>If an input is a 'no' instance, then the verifier rejects for all proofs. </li></ul>",
            "coClass": "coNP"
        },
        "SZK": {
            "name": "SZK",
            "latex_name": "\\mathsf{SZK}",
            "description": "Statistical Zero-Knowledge",
            "information": "The class of decision problems for which a 'yes' instance can be verified by a statistical zero knowledge proof protocol. This is an interactive protocol in which we have a probabilistic polynomia-time verifier and a prover with unbounded resources. Through exchanging messages with the prover, the verifier must be convinced of a 'yes' instance without learning anything about the proof."
        },
        "BPP": {
            "name": "BPP",
            "latex_name": "\\mathsf{BPP}",
            "description": "Bounded-Error Probabilistic Polynomial Time",
            "information": "The class of decision problems solvable by a nondeterministic Turing machine such that <br><br> <ul><li>If we are given a 'yes' instance, then the probability that we accpet is at least 2/3. </li><li> If we are given a 'no' instance, then we reject with probability at least 2/3.</li></ul>"
        },
        "PSPACE": {
            "name": "PSPACE",
            "latex_name": "\\mathsf{PSPACE}",
            "description": "Polynomial Space",
            "information": "The class of decision problems solvable by a Turing machine with polynomial space."
        },
        "EXP": {
            "name": "EXP",
            "latex_name": "\\mathsf{EXP}",
            "description": "Exponential Time",
            "information": "The class of decision problems solvable by a Turing machine in exponential time. Specifically, solvable in time $O(2^{p(n)})$ for any polynomial p."
        },
        "DQP":{
            "name": "DQP",
            "latex_name": "\\mathsf{DQP}",
            "description": "Dynamical Quantum Polynomial-Time",
            "information": "The class of problems solvable by a quantum computer with access to a dynamical simulator. The simulator provides a sample from the probability distribution of all possible classical histories that (sequences of measurement outcomes) that could arise from running a given quantum circuit. Proposed to explore the power of hidden-variable quantum models."
        },
        "L": {
            "name": "L",
            "latex_name": "\\mathsf{L}",
            "description": "Logarithmic Space",
            "information":"Class of decision problems solvable by a Turing machine restricted to $O(\\log(n))$ read-write memory. Note that the input is not part of the memory."
        },
        "NL":{
            "name": "NL",
            "latex_name": "\\mathsf{NL}",
            "description": "Non-deterministic Logarithmic Space",
            "information": "The Non-deterministic version of L."
        },
        "MA":{
            "name": "MA",
            "latex_name": "\\mathsf{MA}",
            "description": "Merlin-Arthur",
            "information": "Class of decision problems solvable by a Merlin-Arthur protocol. A probabilistic version of NP. Similar to AM, except Arthur does not send a question to Merlin and Merlin simply provides a \"proof\". <br> $\\mathsf{MA}_1$, MA with perfect completeness (i.e. in the 'yes'-case, it always accepts), is equal to MA."
        },
        "AM": {
            "name": "AM",
            "latex_name": "\\mathsf{AM}",
            "description": "Arthur-Merlin",
            "information": "Class of decision problems solvable by a Arthur-Merlin protocol. In this protocol, Arthur, a BPP machine, generates a \"question\" which he sends to Merlin, an all-powerful being. Merlin sends back a response which Arthur uses to decide the answer. If the answer is 'yes', then Arthur accepts with probability at least 2/3. If the answer is 'no', then Arthur rejects with probability at least 2/3."
        },
        "QMA(2)": {
            "name": "QMA(2)",
            "latex_name": "\\mathsf{QMA(2)}",
            "description": "Quantum Merlin-Arthur with two unentangled certificates.",
            "information": "For $k\\geq 2$, $\\mathsf{QMA(2)}=\\mathsf{QMA(k)}$ where $\\mathsf{QMA(k)}$ is the class with $k$ unentangled certificates."
        },
        "NEXP":{
            "name": "NEXP",
            "latex_name": "\\mathsf{NEXP}",
            "description": "Non-deterministic Exponential Time",
            "information": "The class of languages decidable by a non-deterministic Turing machine in time $2^{p(n)}$ for some polynomial p."
        },
        "RE":{
            "name": "RE",
            "latex_name": "\\mathsf{RE}",
            "description": "Recursive Enumerable Languages",
            "information": "Class of decision problems for which a 'yes' answer may be verified by a Turing machine in a finite amount of time, while if the answer is 'no' the machine may never halt."
        },
        "A0PP":{
            "name": "A0PP",
            "latex_name": "\\mathsf{A_{0}PP}",
            "description": "One-Sided Analog of AWPP",
            "information": "A class defined using the output of GapP functions with a one-sided gap: zero for 'no' instances and exponentially large for 'yes' instances."
        },
        "AWPP":{
            "name": "AWPP",
            "latex_name": "\\mathsf{AWPP}",
            "description": "Almost WPP",
            "information": "A class defined using the output of GapP functions with bounded acceptance probabilities."
        },
        "R":{
            "name": "R",
            "latex_name": "\\mathsf{R}",
            "description": "Recursive Languages",
            "information": "The class of decision problems solvable by a Turing Machine. Defined in [Tur36] and [Chu41]."
        },
        "RP":{
            "name": "RP",
            "latex_name": "\\mathsf{RP}",
            "description": "Randomized Polynomial Time",
            "information": "The class of decision problems solvable by a probabilistic Turing machine in polynomial time such that if the answer is \"yes\", then the machine accepts with probability at least 1/2. If the answer is \"no\", the machine always rejects."
        },
        "ZPP":{
            "name": "ZPP",
            "latex_name": "\\mathsf{ZPP}",
            "description": "Zero-Error Probabilistic Polynomial Time",
            "information": "The class of decision problems solvable by a randomized algorithm that always gives the correct answer and runs in expected polynomial time. Guarantees zero error, unlike RP and BPP. "
        },
        "CH":{
            "name": "CH",
            "latex_name": "\\mathsf{CH}",
            "description": "Counting Hierarchy",
            "information": " The counting hierarchy is an analog of the polynomial hierarchy using PP instead of NP. The hierarchy is equivalent to a tower of PP oracles. For example $C_1H = PP$, $C_2H = PP^{PP}$, $C_3H = PP^{PP^{PP}}$ and so on. The class CH is the union over all of these."
        },
        "PH":{
            "name": "PH",
            "latex_name": "\\mathsf{PH}",
            "description": "Polynomial Hierarchy",
            "information": "A hierarchy of complexity classes that can be defined by applying a sequence of existential and universal quantifiers to a polynomial-time predicate. The hierarchy is equivalent to a tower of NP oracles with constant height - $NP^{NP^{NP^{...^{NP}}}}$. Includes coNP and levels like $\\mathsf{\\Sigma_{k}^{p}}$ and $\\mathsf{\\Pi_{k}^{p}}$."
        },
        "Sigma2":{
            "name": "Sigma2",
            "latex_name": "\\mathsf{\\Sigma_{2}^{p}}",
            "description": "NP with an NP oracle",
            "information": "Together with Pi2 comprises the second level of the polynomial hierarchy."
        },
        "Pi2":{
            "name": "Pi2",
            "latex_name": "\\mathsf{\\Pi_{2}^{p}}",
            "description": "co-NP with an NP oracle",
            "information": "Together with Sigma2 comprises the second level of the polynomial hierarchy."
        },
        "AC0":{
            "name":"AC0",
            "latex_name":"\\mathsf{AC^0}",
            "description":"Level 0 of AC",
            "information":"The class of constant-depth, polynomial-size circuits with unbounded fan-in AND, OR, and NOT gates. The smallest class in the AC hierarchy. Consists of all families of circuits of constant depth and polynomial size, with unbounded fan-in AND, OR, and NOT gates. Integer addition and subtraction is computable in AC0, but multiplication is not."
        },
        "TC0":{
            "name":"TC0",
            "latex_name":"\\mathsf{TC^0}",
            "description":"Level 0 of TC",
            "information":"The class of constant-depth, polynomial-size circuits with unbounded fan-in AND, OR, and MAJ (Majority) gates. The smallest class in the TC hierarchy. Consists of all families of circuits of constant depth polynomial size, with unbounded fan-in AND, OR, NOT, and MAJ (Majority) gates. Contains several problems like sorting n n-bit numbers, multiplying two n-bit integers, and integer division. Commonly used to model the computational complexity of bounded-depth neural networks. Strictly more powerful than AC0."
        },
        "NC0":{
            "name":"NC0",
            "latex_name":"\\mathsf{NC^0}",
            "description":"Level 0 of NC",
            "information":"The class of constant-depth, polynomial-size circuits with binary AND, OR gates and unary NOT gates. Consists of all families of circuits of constant-depth, polynomial-size circuits with bounded fan-in AND, OR gates and NOT gates. Models extremely local computation."
        },
        "NC1":{
            "name":"NC1",
            "latex_name":"\\mathsf{NC^1}",
            "description":"Level 1 of NC",
            "information":"The class of O(\\log (n)) depth, polynomial-size circuits with binary AND, OR gates and unary NOT gates. Like NC0, but allows depths $O(\\log(n))$ instead of constant depth. Can compute things like integer addition, balanced parenthesis checking, and regular expression matching."
        },
        "AC1":{
            "name":"AC1",
            "latex_name":"\\mathsf{AC^1}",
            "description":"Level 1 of AC",
            "information":"The class of O(\\log (n)) depth, polynomial-size circuits with unbounded fan-in AND, OR, and NOT gates. Like AC0, but allows depths of $O(\\log(n))$ instead of constant depth."
        },
        "TC1":{
            "name":"TC1",
            "latex_name":"\\mathsf{TC^1}",
            "description":"Level 1 of TC",
            "information":"The class of O(\\log (n)) depth, polynomial-size circuits with unbounded fan-in AND, OR, and MAJ (Majority) gates. Like TC0, but allows depths $O(\\log(n))$ instead of constant depth."
        },
        "CZK":{
            "name":"CZK",
            "latex_name":"\\mathsf{CZK}",
            "description":"Computational Zero-Knowledge",
            "information":"The class of decision problems solvable by a zero-knowledge proof system where the distributions which the verifier can simulate are computationally indistinguishable from the distributions which the verifier can simulate through interaction with the prover."
        },
        "P/poly":{
            "name":"P/poly",
            "latex_name":"\\mathsf{P/poly}",
            "description":"P with polynomial advice",
            "information":"The class of decision problems solvable by a polynomial-time Turing machine with a polynomial-size advice string. Equals $\\mathsf{BPP/poly}$."
        },
        "BQP/poly":{
            "name":"BQP/poly",
            "latex_name":"\\mathsf{BQP/poly}",
            "description":"BQP with polynomial advice",
            "information":"The class of decision problems solvable by a BQP machine with a polynomial-size advice string with probability at least $2/3$, even if the advice is bad."
        },
        "BQP/qpoly":{
            "name":"BQP/qpoly",
            "latex_name":"\\mathsf{BQP/qpoly}",
            "description":"BQP with polynomial quantum advice",
            "information":"The class of decision problems solvable by a polynomial-time quantum Turing machine with a polynomial-size advice quantum state."
        },
        "QCPH":{
            "name":"QCPH",
            "latex_name":"\\mathsf{QCPH}",
            "description":"Quantum-Classical Polynomial Hierarchy",
            "information":"The class of languages solvable by a constant number of alternating classical quantifiers followed by a quantum verifier.\n Defined in [GSSSY18]. "
        },
        "QPH":{
            "name":"QPH",
            "latex_name":"\\mathsf{QPH}",
            "description":"Quantum Polynomial Hierarchy",
            "information":"A generalization of PH where the verifier is a quantum circuit and the proofs are quantum states. More formally, the class of languages solvable by a constant number of alternating quantum quantifiers followed by a quantum verifier\n Defined in [GSSSY18]."
        },
        "IP":{
            "name":"IP",
            "latex_name":"\\mathsf{IP}",
            "description":"Interactive Proof System",
            "information":"The class of problems solvable by an interactive proof system with a probabilistic polynomial time (BPP) verifier and an unbounded prover for a polynomial number of rounds. Equal to PSPACE [Sha92]."
        },
        "BPPPath":{
            "name":"BPPPath",
            "latex_name":"\\mathsf{BPP_{\\text{path}}}",
            "description":"Threshold BPP",
            "information":"Also known as PostBPP."
        },
        "MIP":{
            "name":"MIP",
            "latex_name":"\\mathsf{MIP}",
            "description":"Multi-Prover Interactive Proof System",
            "information":"Similar to IP, except there are multiple provers, and the verifier can exchange messages with many provers. The provers cannot communicate with one another. Equal to NEXP [BFL91]."
        },
        "MIPStar":{
            "name":"MIPStar",
            "latex_name":"\\mathsf{MIP^{*}}",
            "description":"MIP with Quantum Provers",
            "information":"MIP with Quantum provers. Similar to MIP, except the provers can share arbitrarily many entangled qubits. The verifier, and all messages between provers and verifiers are classical. Equal to RE."
        },
        "PostBQP":{
            "name":"PostBQP",
            "latex_name":"\\mathsf{PostBQP}",
            "description":"BQP with Postselection",
            "information":"BQP enhanced with the ability to <i>post-select</i> on an event. Formally, it is the set of decision problems solvable by a BQP machine such that: <ul><li>In a yes case, conditioned on measuring 1 in the first qubit, the second qubit outputs 1 with probability at least $2/3$.</li><li>In a no case, conditioned on measuring 1 in the first qubit, the second qubit outputs 1 with probability at most $1/3$.</li></ul> <br> Defined in [Aar04] as a quantum version of BPPPath."
        },
        "EQP":{
            "name":"EQP",
            "latex_name":"\\mathsf{EQP}",
            "description":"Exact Quantum Polynomial Time",
            "information":"Same as BQP, except we output the correct answer with probability 1."
        },
        "LWPP":{
            "name":"LWPP",
            "latex_name":"\\mathsf{LWPP}",
            "description":"Length-Dependent Wide $\\mathsf{PP}$",
            "information":" A class defined using GapP functions where the gap depends only on input length."
        },
        "CL":{
            "name":"CL",
            "latex_name":"\\mathsf{CL}",
            "description":"Catalytic Logarithmic Space",
            "information":"A class that extends L by allowing a polynomial-sized tape called a catalytic tape. The tape can is read/write during computation but must be restored to its original state at the end of computation. The logarithmic space bound still applies to the primary (non-catalytic) work tape."
        },
        "QMA1":{
            "name":"QMA1",
            "latex_name":"\\mathsf{QMA_{1}}",
            "description":"One-sided $\\mathsf{QMA}$",
            "information":"QMA, except for a \"yes\" instance, there exists a state which is accepted with probability 1. It has been shown that Quantum k-SAT is $\\mathsf{QMA_{1}}$-complete for $k\\geq 3.$"
        },
        "AH":{
            "name":"AH",
            "latex_name":"\\mathsf{AH}",
            "description":"Arithmetic Hierarchy",
            "information":"Analog of PH in computability theory."
        },
        "SBQP":{
            "name":"SBQP",
            "latex_name":"\\mathsf{SBQP}",
            "description":"Small Bounded-Error Quantum Polynomial-Time",
            "information":"The class of decision problems for which there exists a polynomial-time quantum algorithm which for some polynomial $p(n)$: <br><br> <ul> <li> If the answer is 'yes', then the algorithm accepts with probability at least $2^{-p(n)}$. </li> <li> If the answer is 'no', then the algorithm accepts with probability at most $2^{-p(n)-1}$. </li></ul>"
        },
        "SBP":{
            "name":"SBP",
            "latex_name":"\\mathsf{SBP}",
            "description":"Small Bounded-Error Probabilistic Polynomial-Time",
            "information":"The class of decision problems for which there exists some $\\mathsf{\\#P}$ function $f$ and $\\mathsf{FP}$ function $g$ such that <br><br> <ul> <li> If the answer is 'yes', then $f(x) > g(x)$ </li> <li> If the answer is 'no', then $f(x) < g(x)/2$ </li></ul>"
        },
        "PP/poly":{
            "name":"PP/poly",
            "latex_name":"\\mathsf{PP/poly}",
            "description":"Nonuniform $\\mathsf{PP}$",
            "information":"PP with polynomial advice."
        },
        "CequalsP":{
            "name":"CequalsP",
            "latex_name":"\\mathsf{C_{=}P}",
            "description":"Exact-Counting Polynomial-Time",
            "information":"The class of decision problems solvable by an NP machine such that the number of accepting paths exactly equals the number of rejecting paths, if and only if the answer is 'yes.'",
            "coClass":"coCequalsP"
        },
        "BQP/mpoly":{
            "name":"BQP/mpoly",
            "latex_name":"\\mathsf{BQP/mpoly}",
            "description":"BQP with polynomial merlin-like advice",
            "information":"The class of decision problems solvable by a BQP machine with a polynomial-size advice string with probability at least $2/3$ when the advice is good."
        },
        "PsharpP":{
            "name":"PsharpP",
            "latex_name":"\\mathsf{P^{\\#P}}",
            "description":"P with #P oracle",
            "information":"The class of decision problems solvable by a P machine with a #P oracle. Equals $\\mathsf{P^{\\mathsf{PP}}}$.<br>Contains PH [Tod91]."
        },
        "coNP":{
            "name":"coNP",
            "latex_name":"\\mathsf{coNP}",
            "description":"Complement of $\\mathsf{NP}$",
            "information":"The class of decision problems for which 'no' answers are efficiently verifiable. Specifically: <br><br> <ul> <li> There exists a proof for all 'no' instances such that the verifier accepts wih certainty. </li> <li>If an input is a 'yes' instance, then the verifier rejects for all proofs. </li></ul>",
            "coClass": "NP"
        },
        "QCMA/poly":{
            "name":"QCMA/poly",
            "latex_name":"\\mathsf{QCMA/poly}",
            "description":"QCMA with polynomial size advice",
            "information":"QCMA with polynomial size advice"
        },
        "QCMA/qpoly":{
            "name":"QCMA/qpoly",
            "latex_name":"\\mathsf{QCMA/qpoly}",
            "description":"QCMA with polynomial size quantum advice",
            "information":"QCMA with polynomial size quantum advice"
        },
        "QMA/poly":{
            "name":"QMA/poly",
            "latex_name":"\\mathsf{QMA/poly}",
            "description":"QMA with polynomial size advice",
            "information":"QMA with polynomial size advice"
        },
        "QMA/qpoly":{
            "name":"QMA/qpoly",
            "latex_name":"\\mathsf{QMA/qpoly}",
            "description":"QMA with polynomial quantum size advice",
            "information":"QMA with polynomial quantum size advice"
        },
        "PSPACE/poly":{
            "name":"PSPACE/poly",
            "latex_name":"\\mathsf{PSPACE/poly}",
            "description":"PSPACE with polynomial size advice",
            "information":"PSPACE with polynomial size advice"
        },
        "BQPSPACE/qpoly":{
            "name":"BQPSPACE/qpoly",
            "latex_name":"\\mathsf{BQPSPACE/qpoly}",
            "description":"BQPSPACE with polynomial quantum size advice",
            "information":"BQPSPACE with polynomial quantum size advice."
        },
        "QAM": {
            "name":"QAM",
            "latex_name":"\\mathsf{QAM}",
            "description":"Quantum Arthur-Merlin",
            "information":"A quantum version of the Arthur-Merlin protocol. Specifically, Arthur flips several coins, sends their results to Merlin, and Merlin responds with a quantum state. Arthur's verification protocol takes the coin flips and Merlin's quantum state as input."
        },
        "QIP[2]": {
            "name":"QIP[2]",
            "latex_name":"\\mathsf{QIP[2]}",
            "description":"QIP with Two Messages.",
            "information":"Quantum Interactive Proof system with two messages exchanged between the prover and the verifier."
        },
        "BQPSPACE":{
            "name":"BQPSPACE",
            "latex_name":"\\mathsf{BQPSPACE}",
            "description":"Bounded-Error Quantum PSPACE.",
            "information":"PSPACE, except the machine is a quantum Turing machine and the answer is correct with at least $2/3$ probability."
        },
        "BQPCTC":{
            "name":"BQPCTC",
            "latex_name":"\\mathsf{BQP_{CTC}}",
            "description":"BQP with Closed Timelike Curves",
            "information":"BQP with access to two types of qubits, casuality-respecting qubits and CTC qubits. It is equal to PSPACE [AW08]."
        },
        "PCTC":{
            "name":"PCTC",
            "latex_name":"\\mathsf{P_{CTC}}",
            "description":"P with Closed Timelike Curves",
            "information":"P with access to CTC bits. It is equal to PSPACE [AW08]."
        },
        "coCequalsP":{
            "name":"coCequalsP",
            "latex_name":"\\mathsf{coC_{=}P}",
            "description":"Complement of CequalsP",
            "information":"The class of decision problems solvable by an NP machine such that the number of accepting paths is not equal to the number of rejecting paths, if and only if the answer is 'yes'. Equlas NQP [FGHP98].",
            "coClass":"CequalsP"
        },
        "NQP":{
            "name":"NQP",
            "latex_name":"\\mathsf{NQP}",
            "description":"Non-deterministic Quantum Polynomial-Time",
            "information":"The class of decision problems solvable by a quantum Turing machine such that a particular accept state has a non-zero amplitude if and only if the answer is 'yes'. Equals coCequalsP [FGHP98]. Contrast with QMA."
        },
        "APP":{
            "name":"APP",
            "latex_name":"\\mathsf{APP}",
            "description":"Amplified PP",
            "information":"The class of decision problems for which for all polynomials $p(n)$, there exist two GapP functions $f,g$ such that <br> <br> <ul> <li> If the answer is yes, then $1 > f(x)/g(1^n) > 1-2^{-p(n)}$ </li> <li> If the answer is no, $0 < f(x)/g(1^n) < 2^{-p(n)}$</li></ul> <br> <br> It has been shown that it is low for PP."
        },
        "ExistsBPP":{
            "name":"ExistsBPP",
            "latex_name":"\\mathsf{\\exists BPP}",
            "description":"BPP with an existential quantifier",
            "information":"The class of decision problems for which there exists a BPP machine M such that, for all inputs x,<ul> <li> If x is a 'yes' instance, there exists a y such that M(x,y) accepts. </li> <li> If x is a 'no' instance, M(x,y) rejects for all y. </li></ul> Alternatively, it is defined as $\\mathsf{NP}^{\\mathsf{BPP}}$. It appears obviously equal to MA, but there exists oracle separating them [FFKL03]."
        },
        "ParityP":{
            "name":"ParityP",
            "latex_name": "\\mathsf{\\oplus P}",
            "description": "Parity P",
            "information": "The class of decision problems solvable by an NP machine M such that, <ul> <li> M has an odd number of accepting paths if x is a 'yes' instance </li> <li> M has an even number of accepting paths if x is a 'no' instance. </li></ul>"
        },
        "MP":{
            "name":"MP",
            "latex_name":"\\mathsf{MP}",
            "description":"Middle-Bit P",
            "information":"The class of decision problems for which there exists a $\\mathsf{\\#P}$ function $f$ such that x is a 'yes' instance iff the middle bit of $f(x)$ is 1 (by middle bit, we mean the value of $f(x)$ at index $\\left \\lfloor{1/2 |f(x)|}\\right \\rfloor $). Defined in [GKRST95]."
        },
        "NISQ":{
            "name":"NISQ",
            "latex_name":"\\mathsf{NISQ}",
            "description":"Noisy intermediate-scale quantum",
            "information":"The class of decision problems solvable by a BPP machine with access to a noisy quantum device. Defined in [CCHL23]."
        },
        "RG":{
            "name":"RG",
            "latex_name":"\\mathsf{RG}",
            "description":"Refereed Games",
            "information":"The class of decision problems solvable by a BPP verifier who can exchange a polynomial number of messages with two competing provers. The provers are computationally unbounded and each is trying to convince you of a different output. Note that $RG\\subseteq EXP$ relativizes [KM92], but the opposite direction is not known to relativize. Additionally, $\\mathsf{RG(k)}$ denotes RG where exactly $k$ messages are exchanged with each prover."
        },
        "QRG":{
            "name":"QRG",
            "latex_name":"\\mathsf{QRG}",
            "description": "Quantum Refereed Games",
            "information": "Same as RG, except the verifier is a BQP machine and they can exchange quantum messages with the provers. Equality with EXP was shown in [GW07]."
        },
        "RG(1)":{
            "name":"RG(1)",
            "latex_name":"\\mathsf{RG(1)}",
            "description": "One-turn Refereed Games",
            "information":"RG where the verifier receives a single message from each prover."
        },
        "RG(2)":{
            "name":"RG(2)",
            "latex_name":"\\mathsf{RG(2)}",
            "description": "Two-turn (one-round) Refereed Games",
            "information":"RG where the verifier exchanges only two messages with each prover. Note that the verifiers messages are sent in parallel."
        },
        "QRG(2)":{
            "name":"QRG(2)",
            "latex_name":"\\mathsf{QRG(2)}",
            "description": "Two-turn (one-round) Quantum Refereed Games",
            "information": "QRG where the verifier exchanges only two messages with each prover. Note that the verifiers messages are sent in parallel. Additionally, its definition coincides with the definition of the second level of QPH [GSSSY18]."
        },
        "QRG(1)":{
            "name":"QRG(1)",
            "latex_name":"\\mathsf{QRG(1)}",
            "description": "One-turn Quantum Refereed Games",
            "information": "QRG here the verifier receives a single message from each prover."
        },
        "QEPH":{
            "name":"QEPH",
            "latex_name":"\\mathsf{QEPH}",
            "description": "Quantum Entangle PH",
            "information": "QPH, except the provers may entangle their proofs. Defined in [GY24], who showed that it collapses to its second level (even for polynomially-many rounds)."
        },
        "BQL":{
            "name":"BQL",
            "latex_name":"\\mathsf{BQL}",
            "description":"Bounded-Error Quantum Logspace",
            "information":"BQP, except it is restricted to $O(\\log (n))$ space. <br> It has been shown that allowing for intermediate measurements does not change the resulting class and, in general, for $s(n)=\\Omega (\\log(n))$, $\\mathsf{BQSPACE(s(n)) = \\mathsf{QMASPACE(s(n))}}$ [FR21]."
        },
        "BPL":{
            "name":"BPL",
            "latex_name":"\\mathsf{BPL}",
            "description":"Bounded-Error Probabilistic Logspace",
            "information":"BPP, except is is restricted to $O(\\log (n))$ space. Note that the randomness is read-once, meaning that each random bit is only given once and in order to reference to it again, it must be stored in the working space."
        },
        "BPdotL":{
            "name":"BPdotL",
            "latex_name":"\\mathsf{BP\\cdot L}",
            "description":"Bounded-Error Probabilistic Logspace with multiple access randomness",
            "information":"BPL, except the random bits may be read multiple times. Unlike BPL, it is an open question whether BPdotL (or even $\\mathsf{ZP\\cdot L}$) is contained in P [Nis93]."
        },
        "RL":{
            "name":"RL",
            "latex_name":"\\mathsf{RL}",
            "description":"Randomized Logspace",
            "information":"RP, except it is restricted to $O(\\log (n))$ space. Note that similarly to BPL, the random string can be only read once."
        },
        "DET":{
            "name":"DET",
            "latex_name":"\\mathsf{DET}",
            "description":"Determinant",
            "information":"Class of decision problems which are reducible in L to the problem of computing the determinant of an $n$-by-$n$ matrix of $n$-bit integers."
        },
        "LOSSY":{
            "name":"LOSSY",
            "latex_name":"\\mathsf{LOSSY}",
            "description":"Lossy coding P",
            "information":"Defined as LOSSY$\\mathsf{[P]}$, the class of problems $P$-reducible to the lossy coding problem: <br> Given the pair of circuits $\\textup{Comp}: \\{0,1\\}^n \\rightarrow \\{0,1\\}^{n-1}$ and $\\textup{Decomp}: \\{0,1\\}^{n-1} \\rightarrow \\{0,1\\}^{n}$, the goal is to find some $x\\in \\{0,1\\}^n$ such that $\\textup{Decomp}(\\textup{Comp}(x) \\neq x$ [Kor22]." 
        },
        "NC":{
            "name":"NC",
            "latex_name":"\\mathsf{NC}",
            "description":"Nick's Class",
            "information":"Defined as $\\cup_i \\mathsf{NC^{i}}$ where $\\mathsf{NC^i}$ is the class of decision problems solvable by a uniform family of boolean circuits with polynomial size, fan-in 2 and depth $O(\\log^i(n))$."
        },
        "NC2":{
            "name":"NC2",
            "latex_name":"\\mathsf{NC}^2",
            "description":"Level 2 of NC",
            "information":"NC with depth $O(\\log^2(n))$."
        },
        "AC":{
            "name":"AC",
            "latex_name":"\\mathsf{AC}",
            "description":"Alternating Circuits",
            "information":"Defined as $\\cup_i \\mathsf{AC^i}$ where $\\mathsf{AC^i}$ is the class of decision problems solvable by a uniform family of boolean circuits with polynomial size, unbounded fan-in and depth $O(\\log^i(n))$."
        },
        "TC":{
            "name":"TC",
            "latex_name":"\\mathsf{TC}",
            "description":"Threshold Circuits",
            "information":"Defined as $\\cup_i \\mathsf{TC^i}$ where $\\mathsf{TC^i}$ is the class of decision problems solvable by uniform family of circuits using AND, OR and MAJ (majority) gates, polynomial-size, unbounded fan-in and depth $O(\\log^i(n))$."
        },
        "PL":{
            "name":"PL",
            "latex_name":"\\mathsf{PL}",
            "description":"Probabilistic Logspace",
            "information":"PP, except it is restricted to $O(\\log (n))$ space.<br> Interestringly, it is self-low (i.e. $\\mathsf{PL}^{\\mathsf{PL}} = \\mathsf{PL}$) [HO02], an open problem for PP."
        },
        "coNL":{
            "name":"coNL",
            "latex_name":"\\mathsf{coNL}",
            "description":"Complement of NL",
            "information": "The equality with NL was shown in [Imm88][Sze88] whose result extends to $\\mathsf{NSPACE}(s(n)) = \\mathsf{co-NSPACE}(s(n))$ for any $s(n) \\geq \\log (n)$."
        },
        "NPSPACE":{
            "name":"NPSPACE",
            "latex_name":"\\mathsf{NPSPACE}",
            "description": "Non-deterministic PSPACE",
            "information": "Note that while the equality with PSPACE holds due to [Sav70], there exists an oracle relative to which NPSPACE is not contained in EXP [GTWB90] (when the oracle tape can have unbounded length)."
        },
        "L/poly":{
            "name":"L/poly",
            "latex_name":"\\mathsf{L/poly}",
            "description":"L with polynomial advice",
            "information":"Class of decision problems solvable by an L machine provided with a polynomial-sized read-only tape whose contents depend only on the size of the input."
        },
        "ParityL":{
            "name":"ParityL",
            "latex_name":"\\mathsf{\\oplus L}",
            "description":"Parity L",
            "information":"Is the same to L as ParityP is to P. Interestingly, it is self-low (i.e. $\\mathsf{\\oplus L}^{\\mathsf{\\oplus L}} = \\mathsf{\\oplus L}$) [HRV00]."
        },
        "FH":{
            "name":"FH",
            "latex_name":"\\mathsf{FH}",
            "description":"Fourier Hierarchy",
            "information":"Defined in [Shi05] as $\\cup_k \\mathsf{FH_k}$ where $\\mathsf{FH_k}$ is the class of decison problems solvable using a uniform famiily of polynomial-sized quantum circuits with at most $k$ Fourier transforms and all other gates preserving the computational basis. Note that $\\mathsf{FH_0} = $ P and $\\mathsf{FH_1} = $ BPP."
        },
        "NPcapcoNP":{
            "name":"NPcapcoNP",
            "latex_name":"\\mathsf{NP \\cap coNP}",
            "description":"Intersection of NP and coNP",
            "information":"The class of decision problems both in NP and coNP."
        },
        "AP":{
            "name":"AP",
            "latex_name":"\\mathsf{AP}",
            "description":"Alternating P",
            "information":"Class of decision problems solvable by a polynomial-time <i>alternating</i> Turing machine. An alternating Turing machine is a generalization of a non-deterministic Turing machine where except for the accept and reject states, each state is labeled with a $\\exists$ or $\\forall$ quantifier. The machine accepts if and only if they accept over the appropriate quantifier with which this state was labeled."
        }
    }
}
